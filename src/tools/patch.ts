import { Tool } from './types';
import * as fs from 'fs/promises';
import { logger } from '@/logger';
import { applyPatch } from 'diff';

export class PatchTool implements Tool {
  name = 'patch';
  description =
    'Applies a Git-style unified patch string to a specified file. This tool modifies the file directly by applying the changes described in the patch. The patch string should be in the unified diff format, typically generated by `git diff`.';
  schema = {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description:
          'The absolute file system path to the file that needs to be patched. This path must start from the root (e.g., C:\\Users\\... or /home/user/...).',
      },
      patch: {
        type: 'string',
        description:
          'The content of the Git-style unified patch (e.g., the output of `git diff`). This string will be applied to the file.',
      },
    },
    required: ['path', 'patch'],
    additionalProperties: false,
  };

  async execute(args: { path: string; patch: string }): Promise<string> {
    const { path: filePath, patch: patchContent } = args;

    if (!patchContent) {
      logger.info(`[PatchTool] Received empty patch for '${filePath}'`);
      return `No changes in the patch for '${filePath}'`;
    }

    let fileContent: string;

    try {
      await fs.access(filePath);

      let fileContent = await fs.readFile(filePath);
    } catch (err) {
      logger.error(`Failed to access file on ${filePath}: ${err.message}`);
    }

    try {
      const patchedContent = applyPatch(fileContent, patchContent);

      if (patchedContent === false) {
        logger.error('Patch could not be applied.');
      }

      await fs.writeFile(filePath, patchedContent as string);

      return 'Succesfully patched file';
    } catch (err) {
      logger.error(`Failed to patch file on ${filePath}: ${err.message}`);
    }
  }
}
